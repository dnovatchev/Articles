declare namespace f = "http://www.w3.org/2005/xpath-functions-2025";
declare record f:generator 
   ( initialized as xs:boolean,
     end-reached as xs:boolean,
     get-current as   fn($this as f:generator) as item()*,
     move-next as   fn($this as f:generator) as f:generator,  (: as item()*, :)
     to-array :=   fn($this as f:generator)
     {
       while-do( [$this, []],
              function( $inArr) 
              { $inArr(1)?initialized and not($inArr(1)?end-reached) },                 
              function($inArr) 
              { array{$inArr(1) =?> move-next(), 
                      array:append($inArr(2), $inArr(1) =?> get-current())
                     } 
               }         
     ) (2)
     },
     
     take := fn($this as f:generator, $n as xs:integer) as f:generator
     {
      let $gen := if(not($this?initialized)) then $this?move-next()
                    else $this
       return
         if($gen?end-reached or $n le 0) then $gen =?> empty-generator()
          else
            let $current := $gen =?> get-current(),
                $newResultGen := map:put($gen, "get-current", fn($this as f:generator){$current}),
                $nextGen := $gen =?> move-next()
             return
               if($nextGen?end-reached) then $newResultGen
                 else
                   let
                       $newResultGen2 :=  map:put($newResultGen, "move-next", fn($this as f:generator) {$nextGen =?> take($n -1)}) 
                     return
                       $newResultGen2  
      },
      
      take-while := fn($this as f:generator, $pred as function(item()*) as xs:boolean) as f:generator
      {
        let $gen := if(not($this?initialized)) then $this =?> move-next()
                      else $this
         return
           if($gen?end-reached) then $gen =?> empty-generator($gen)
            else      
              let $current := $gen =?> get-current()
                return
                  if(not($pred($current))) then $gen =?> empty-generator()
                  else
                    let $newResultGen := map:put($gen, "get-current",   fn($this as f:generator){$current}),
                        $nextGen := $gen =?> move-next()
                     return
                        if($nextGen?end-reached) then $newResultGen
                        else
                          let $newResultGen2 :=  map:put($newResultGen, "move-next",   fn($this as f:generator) {$nextGen =?> take-while($pred)}) 
                           return $newResultGen2  
      },
     
     skip-strict := fn($this as f:generator, $n as xs:nonNegativeInteger, $issueErrorOnEmpty as xs:boolean) as f:generator
     {
            if($n eq 0) then $this
              else if($this?end-reached) 
                     then if($issueErrorOnEmpty)
                           then error((), "Input Generator too-short") 
                           else $this =?> empty-generator()
              else 
                let $gen := if(not($this?initialized)) then $this =?> move-next()
                             else $this
                  return
                    if(not($gen?end-reached)) then ($gen =?> move-next()) =?> skip-strict($n -1, $issueErrorOnEmpty)
                      else $gen =?> empty-generator($gen)                  

     },
     skip := fn($this as f:generator, $n as xs:nonNegativeInteger) as f:generator
     {
       $this =?> skip-strict($n, false())
     },
     
     skip-while := fn($this as f:generator, $pred as function(item()*) as xs:boolean) as f:generator
     {
        let $gen := if(not($this?initialized)) then $this =?> move-next()
                      else $this
         return
           if($gen?end-reached) then $gen =?> empty-generator()
            else
              let $current := $gen =?> get-current()
               return
                 if(not($pred($current))) then $gen
                  else ($gen =?> move-next()) =?> skip-while( $pred)                     
     },
     
     some := fn($this as f:generator) as xs:boolean
     {
       $this?initialized and not($this?end-reached)
     },
     
     some-where := fn($this as f:generator, $pred) as xs:boolean
     {
       $this =?> filter($pred) =?> some()
     },
     
     first-where := fn($this as f:generator, $pred) as item()*
     {
       $this =?> filter($pred) =?> head()
     },     
     
     subrange := fn($this as f:generator, $m as xs:positiveInteger, $n as xs:integer) as f:generator
     {
       $this =?> skip($m - 1) =?> take($n - $m + 1)
     },
     
     chunk := fn($this as f:generator, $size as xs:positiveInteger) as f:generator
     {
        let $gen := if(not($this?initialized)) then $this =?> move-next()
                      else $this
         return
           if($gen?end-reached) then $gen =?> empty-generator()
           else
             let $thisChunk := $gen =?> take($size) =?> to-array(),
                 $cutGen := $gen =?> skip($size),
                 $resultGen := $gen => map:put("get-current", fn($this as f:generator){$thisChunk})
                                    => map:put("move-next", fn($this as f:generator){$cutGen =?> chunk($size)})
              return $resultGen
     },
     
     head := fn($this as f:generator) as item()* {$this =?> take(1) =?> get-current()},
     tail := fn($this as f:generator) as f:generator {$this =?> skip(1)},
     
     at := fn($this as f:generator, $ind as xs:nonNegativeInteger) as item()* {$this =?> subrange($ind, $ind) =?>get-current()},
     
     contains := fn($this as f:generator, $value as item()*) as xs:boolean
     {
       let $gen := if(not($this?initialized)) then $this =?> move-next()
                     else $this
        return
          if($gen?end-reached) then false()
           else
             let $current := $gen =?> get-current()
               return
                  if(deep-equal($current, $value)) then true()
                   else ($gen =?> move-next()) =?> contains($value)                  
     },
           
     for-each := fn($this as f:generator, $fun as function(*)) as f:generator
     {
      let $gen := if(not($this?initialized)) then $this =?> move-next()
                    else $this        
       return
         if($gen?end-reached) then $gen =?> empty-generator($gen)
          else
           let $current := $fun($gen =?> get-current()),
                $newResultGen := map:put($gen, "get-current",   fn($this as f:generator){$current}),
                $nextGen := $gen =?> move-next()
            return
              if($nextGen?end-reached) then $newResultGen
                else
                  let $newResultGen2 :=  map:put($newResultGen, "move-next",   fn($this as f:generator) {$nextGen =?> for-each($fun)}) 
                     return
                       $newResultGen2                    
      },
      
      for-each-pair := fn($this as f:generator, $gen2 as f:generator, $fun as function(*)) as f:generator
      {
        let $gen := if(not($this?initialized)) then $this =?> move-next()
                    else $this,
            $gen2 := if(not($gen2?initialized)) then $gen2 =?> move-next()
                    else $gen2
         return
      if($gen?end-reached or $gen2?end-reached) then $gen =?> empty-generator() 
       else  
         let $current := $fun($gen =?> get-current(), $gen2 =?> get-current()),
             $newResultGen := map:put($gen, "get-current",   fn($this as f:generator){$current}),
             $nextGen1 := $gen =?> move-next(),
             $nextGen2 := $gen2 =?> move-next()
          return
             if($nextGen1?end-reached or $nextGen2?end-reached) then $newResultGen
               else
                 let $newResultGen2 := map:put($newResultGen, "move-next", fn($this as f:generator){$nextGen1 =?> for-each-pair($nextGen2, $fun)})
                   return
                     $newResultGen2                    
      },
      
      zip := fn($this as f:generator, $gen2 as f:generator) as f:generator
      {
        $this =?> for-each-pair($gen2, fn($x1, $x2){[$x1, $x2]})
      },

      concat := fn($this as f:generator, $gen2 as f:generator) as f:generator
      {
        let $gen := if(not($this?initialized)) then $this =?> move-next()
                    else $this,
            $gen2 := if(not($gen2?initialized)) then $gen2 =?> move-next()
                    else $gen2,
            $resultGen := if($gen?end-reached) then $gen2
                            else if($gen2?end-reached) then $gen
                            else
                              $gen  => map:put( "move-next", 
                                                  fn($this as f:generator)
                                                 {
                                                 let $nextGen := $gen =?> move-next()
                                                   return 
                                                     $nextGen =?> concat($gen2)
                                                 }
                                              )                                   
        return 
           $resultGen            
      },

      append := fn($this as f:generator, $value as item()*) as f:generator
      {
        let $gen := if(not($this?initialized)) then $this =?> move-next()
                    else $this,
            $genSingle := $gen => map:put("get-current",   fn($this as f:generator){$value})
                               => map:put("move-next",   fn($this as f:generator){$gen =?> empty-generator()})
                               => map:put("end-reached", false())
         return
           $gen =?> concat($genSingle)                  
      },
      
      prepend := fn($this as f:generator, $value as item()*) as f:generator
      {
          let $gen := if(not($this?initialized)) then $this =?> move-next()
              else $this,
          $genSingle := $gen => map:put("get-current",   fn($this as f:generator){$value})
                             => map:put("move-next",   fn($this as f:generator){$gen =?> empty-generator()})
         return
           $genSingle =?> concat($gen)    
      },
      
      insert-at := fn($this as f:generator, $pos as xs:positiveInteger, $value as item()*) as f:generator
      {
        let $genTail := $this =?> skip-strict($pos - 1, true())
         return
            if($pos gt 1)
              then ($this =?> take($pos - 1)) =?> append($value) =?> concat($genTail)              
              else $genTail =?> prepend($value)               
      },
      
      remove-at := fn($this as f:generator, $pos as xs:nonNegativeInteger) as f:generator
      {
        let $genTail := $this =?> skip-strict($pos, true())
          return
            if($pos gt 1)
              then ($this =?> take($pos - 1)) =?> concat($genTail)
              else $genTail
      },
      
      remove-where := fn($this as f:generator, $predicate as function(item()*) as xs:boolean) as f:generator
      {
        let $gen := if(not($this?initialized)) then $this =?> move-next()
                      else $this
          return
            $gen =?> filter(fn($x){not($predicate($x))})  
      },
      
      distinct fn($this as f:generator) as f:generator
      {
        let $gen := if(not($this?initialized)) then $this =?> move-next()
                      else $this
         return
           if($gen?end-reached) then $gen
           else
             let $priorValue := $gen =?> get-current()
               return
                 $gen => map:put("move-next",   
                                 fn($this as f:generator)
                                 {   
                                   ($gen =?> tail()) 
                                       =?> remove-where(fn($x){deep-equal($priorValue, $x)})
                                       =?> distinct()
                                 }
                                )
      },
    
      replace := fn($this as f:generator, $funIsMatching as function(item()*) as xs:boolean, $replacement as item()*) as f:generator
      {
        if($this?end-reached) then $this
          else
            let $current := $this =?> get-current()
              return
                if($funIsMatching($current))
                  then let $nextGen := $this =?> move-next()
                     return
                       $this => map:put("get-current",   fn($this as f:generator) {$replacement})
                             => map:put("move-next",   fn($this as f:generator) { $nextGen } 
                                  )
                  else (: $current is not the match for replacement :)
                    let $nextGen := $this =?> move-next()
                      return $this => map:put("move-next", 
                                             fn($this as f:generator)
                                             {
                                               let $intendedReplace := function($z) {$z =?> replace($funIsMatching, $replacement)}
                                                return
                                                  if($nextGen?end-reached) then $nextGen
                                                  else $intendedReplace($nextGen)
                                              }
                                        )
      },
      
      reverse := fn($this as f:generator) as f:generator
      {
        if($this?end-reached) then $this =?> empty-generator()
          else
           let $current := $this =?> get-current()
             return
               $this =?> tail() =?> reverse() =?> append($current)
      },

      filter := fn($this as f:generator, $pred as function(item()*) as xs:boolean) as f:generator
      {
             if($this?initialized and $this?end-reached) then $this =?> empty-generator()
              else
                let $getNextGoodGen := function($gen as map(*), 
                                                $pred as function(item()*) as xs:boolean)
                   {
                    if($gen?end-reached) then $gen =?> empty-generator()
                    else
                      let $mapResult := 
                            while-do(
                                     $gen,
                                     function($x) { not($x?end-reached) and not($pred($x =?> get-current()))},
                                     function($x) { $x =?> move-next() }
                                     )   
                      return 
                        if($mapResult?end-reached) then $gen =?> empty-generator()
                         else $mapResult                           
                   },
                   
                   $gen := if($this?initialized) then $this 
                             else $this =?> move-next(),
                   $nextGoodGen := $getNextGoodGen($gen, $pred)
                return
                  if($nextGoodGen?end-reached) then $nextGoodGen =?> empty-generator()
                  else
                    $nextGoodGen  => map:put("inputGen", $nextGoodGen)
                                  => map:put("move-next", 
                                              fn($this as f:generator) 
                                              {
                                                let $nextGoodGen := $getNextGoodGen($this?inputGen =?> move-next(), $pred)
                                                  return
                                                    if($nextGoodGen?end-reached) then $nextGoodGen =?> empty-generator()
                                                    else
                                                       $nextGoodGen => map:put("move-next",   
                                                                               fn($this as f:generator) 
                                                                               {($nextGoodGen =?> move-next()) =?> filter($pred)}
                                                                               )
                                                                    => map:put("inputGen", $nextGoodGen)
                                               }
                                           )
        },     
        fold-left := fn($this as f:generator, $init as item()*, $action as fn(*)) as item()*
        {
          if($this?end-reached) then $init
            else $this =?> tail() =?> fold-left($action($init, $this =?> get-current()), $action)
        },
        
        fold-right := fn($this as f:generator, $init as item()*, $action as fn(*)) as item()*
        {
          if($this?end-reached) then $init          
            else $action($this =?> head(), $this =?> tail() =?> fold-right($init, $action))
        },
        
        fold-lazy := fn($this as f:generator, $init as item()*, $action as fn(*), $shortCircuitProvider as function(*)) as item()*
        {
          if($this?end-reached) then $init
          else
           let $current := $this =?> get-current()
             return
               if(function-arity($shortCircuitProvider($current, $init)) eq 0)
                 then $shortCircuitProvider($current, $init)()
                 else $action($current, ($this =?> move-next()) =?> fold-lazy($init, $action, $shortCircuitProvider))
        },
        
        scan-left := fn($this as f:generator, $init as item()*, $action as fn(*)) as f:generator
        {
          let $resultGen := $this =?> empty-generator() 
                                   => map:put("end-reached", false())
                                   => map:put("get-current", fn($this as f:generator){$init})
           return
             if($this?end-reached) 
               then $resultGen => map:put("move-next",   fn($this as f:generator){$this =?> empty-generator()})
               else
                 let $resultGen := $resultGen => map:put("get-current",   fn($this as f:generator){$init}),
                     $partialFoldResult := $action($init, $this =?> get-current())
                   return
                     let $nextGen := $this =?> move-next()
                      return
                        $resultGen => map:put("move-next",   fn($this as f:generator)
                                              { 
                                                  $nextGen =?> scan-left($partialFoldResult, $action)
                                               }
                                              )                        
        },
      
        scan-right := fn($this as f:generator, $init as item()*, $action as fn(*)) as f:generator
        {
          $this =?> reverse() =?> scan-left($init, $action) =?> reverse()                         
        },
                
        slice := fn($this as f:generator, $start as xs:positiveInteger, $end as xs:positiveInteger, $step as xs:positiveInteger) as f:generator
        {
         let $gen := if(not($this?initialized)) then $this =?> move-next()
                    else $this
          return
            if($this?end-reached) then $this =?> empty-generator()
            else
              let $genStart := $gen =?> empty-generator()
                            => map:put("last", $start -$step)
                            => map:put("initialized", true())
                            => map:put("end-reached", false())              
                            => map:put("get-current",  fn($this as f:generator){$this?last +$step})              
                            => map:put("move-next",  fn($this as f:generator)
                                       {map:put($this, "last", $this?last + $step)})
                return  
                  $genStart =?> take-while(fn($n) {$n le $end})
                  
},
        
        make-generator := fn($this as f:generator, $provider as function(*)) as f:generator
        {
         let $gen := if(not($this?initialized)) then $this =?> move-next()
                    else $this,
      $nextDataItemGetter := $provider(0),      
      $nextGen := if(not($nextDataItemGetter instance of function(*))) 
                   then $gen =?> empty-generator()  
                   else $gen =?> empty-generator()
                    => map:put("numDataItems", 1)
                    => map:put("current", $nextDataItemGetter())
                    => map:put("end-reached", false())
                    => map:put("get-current", fn($this as f:generator) {$this?current})
                    => map:put("move-next",  
                                 fn($this as f:generator) 
                                {
                                  let $nextDataItemGetter := $provider($this?numDataItems)
                                    return
                                      if(not($nextDataItemGetter instance of function(*))) then $gen =?> empty-generator()
                                      else
                                        $this => map:put("current", $nextDataItemGetter())
                                          => map:put("numDataItems", $this?numDataItems + 1)
                                }
                               )
   return $nextGen                                                                                      
        },
        
        make-generator-from-array := fn($this as f:generator, $input as array(*)) as f:generator
        {
          let $size := array:size($input),
              $arrayProvider := fn($ind as xs:integer)
                                {
                                  if($ind +1 gt $size) then -1
                                   else fn(){$input($ind + 1)}
                                }
           return $this =?> make-generator($arrayProvider)
        },
        
        make-generator-from-sequence := fn($this as f:generator, $input as item()*) as f:generator
        {
          let $size := count($input),
              $seqProvider := fn($ind as xs:integer)
                                {
                                  if($ind +1 gt $size) then -1
                                   else fn(){$input[$ind + 1]}
                                }
           return $this =?> make-generator($seqProvider)
        },
        
        make-generator-from-map := fn($this as f:generator, $inputMap as map(*)) as f:generator
        {
          let $keys := map:keys($inputMap),
              $size := map:size($inputMap),
              $mapProvider := fn($ind as xs:integer)
              {
                if($ind +1 gt $size) then -1
                  else fn() 
                       {
                         let $key := $keys[$ind + 1]
                          return
                            ( $key, [ $inputMap($key) ])
                       }
              }
            return
              $this =?> make-generator($mapProvider)
        },
        
        to-sequence := fn($this as f:generator) as item()* {$this =?> to-array() => array:items()},     
        
        to-map := fn($this as f:generator) as map(*)
        {
          let $genPairs := $this =?> for-each(fn($x)
                           {
                             let $key := head($x),
                                 $tail := tail($x),
                                 $value := if($tail instance of array(*)) 
                                           then for $ind in 1 to array:size($tail)
                                                 return $tail($ind)
                                           else $tail
                             return
                               map:pair($key, $value)
                           }
                         ) 
           return
             map:of-pairs($genPairs =?> to-sequence())

        },
        
        empty-generator := fn($this as f:generator) as f:generator
        {
          $this => map:put("initialized", true()) => map:put("end-reached", true())
                => map:put("get-current", fn($this as f:generator) {error((),"get-current() called on an empty-generator")})
                => map:put("move-next", fn($this as f:generator) {error((),"move-next() called on an empty-generator")})
        },      
     *
   );

let $gen2ToInf := f:generator(initialized := true(), end-reached := false(), 
                              get-current := fn($this as f:generator){$this?last +1},
                              move-next := fn($this as f:generator)
                              {
                                if(not($this?initialized))
                                  then map:put($this, "initialized", true())
                                  else map:put($this, "last", $this?last + 1)
                              }
                              (: , options := {"last" : 1} :)
                             ) => map:put("last", 1),
    $genN := $gen2ToInf =?> for-each(fn($n) {$n - 1}),
    $gen0toInf := $gen2ToInf =?> for-each(fn($n) {$n - 2}),
    $double := fn($n) {2*$n},
    $sum2 := fn($m, $n) {$m + $n},
    $product := fn($m, $n) {$m * $n},
    $factorial := fn($n) {fold-left(1 to $n, 1, $product)}
  return    
  (
    "$gen2ToInf =?>take(3) =?> to-array()",
    $gen2ToInf =?>take(3) =?> to-array(),
    "================",    
    "$gen2ToInf =?>take(3) =?> skip(2) =?> get-current()",
    $gen2ToInf =?> take(3) =?> skip(2) =?> get-current(),
    (: $gen2ToInf =?>take(3) =?> move-next() =?> move-next() =?> move-next() =?> get-current(), :)
    "================",
    "$gen2ToInf =?> get-current()",
    $gen2ToInf =?> get-current(),
    "$gen2ToInf =?> move-next() =?> get-current()",
    $gen2ToInf =?> move-next()  =?> get-current(),
    "================",
    "$gen2ToInf =?>take(5) instance of f:generator",
    $gen2ToInf =?> take(5) instance of f:generator,
    "==>  $gen2ToInf =?> skip(7) instance of f:generator",
    $gen2ToInf =?> skip(7) instance of f:generator,  
    "================",
    "$gen2ToInf =?> subrange(4, 6) =?> get-current()",
    $gen2ToInf =?> subrange(4, 6) =?> get-current(), 
    "$gen2ToInf =?> subrange(4, 6) =?> move-next() =?> get-current()",
    $gen2ToInf =?> subrange(4, 6) =?> move-next() =?> get-current(),
    "$gen2ToInf =?> subrange(4, 6) =?> move-next() =?> move-next() =?> get-current()",
    $gen2ToInf =?> subrange(4, 6) =?> move-next() =?> move-next() =?> get-current(),
    (: $gen2ToInf =?> subrange(4, 6) =?> move-next() =?> move-next() =?> move-next() =?> get-current() :) (: Must raise error:)    
    "================",    
    "$gen2ToInf =?> subrange(4, 6) =?> head()",
    $gen2ToInf =?> subrange(4, 6) =?> head(),  
    "$gen2ToInf =?> subrange(4, 6) =?> tail() =?> head()",
    $gen2ToInf =?> subrange(4, 6) =?> tail() =?> head(),
    "$gen2ToInf =?> subrange(4, 6) =?> to-array()",
    $gen2ToInf =?> subrange(4, 6) =?> to-array(),
    "$gen2ToInf =?> head()",
    $gen2ToInf =?> head(),
    "==>  $gen2ToInf =?> tail() =?> head()",
    $gen2ToInf =?> tail() =?> head(),
    "================", 
    "$gen2ToInf =?> subrange(4, 6) =?> tail() =?> to-array()",
    $gen2ToInf =?> subrange(4, 6) =?> tail() =?> to-array(),
    "================",
    "$gen2ToInf =?> at(5)",
    $gen2ToInf =?> at(5), 
    "================",
    "$gen2ToInf =?> subrange(1, 5) =?> to-array()",
    $gen2ToInf =?> subrange(1, 5) =?> to-array(),
    "$gen2ToInf =?> subrange(1, 5) =?> for-each($double) =?> to-array()",
    $gen2ToInf =?> subrange(1, 5) =?> for-each($double) =?> to-array(),
    "$gen2ToInf =?>take(5) =?> for-each($double) =?> to-array()",
    $gen2ToInf =?>take(5) =?> for-each($double) =?> to-array(),
    "==>  $gen2ToInf =?> for-each($double) =?> take(5) =?> to-array()",
    $gen2ToInf =?> for-each($double) =?> take(5) =?> to-array(),
    "================",
    "$gen2ToInf =?> subrange(1, 5) =?> to-array()",
    $gen2ToInf =?> subrange(1, 5) =?> to-array(),
    "$gen2ToInf =?> subrange(6, 10) =?> to-array()",
    $gen2ToInf =?> subrange(6, 10) =?> to-array(),
    "$gen2ToInf =?> subrange(1, 5) =?> for-each-pair($gen2ToInf =?> subrange(6, 10), $sum2) =?> to-array()",
    $gen2ToInf =?> subrange(1, 5) =?> for-each-pair($gen2ToInf =?> subrange(6, 10), $sum2) =?> to-array(), 
    "==>  $gen2ToInf =?> for-each-pair($gen2ToInf, $sum2) =?> take(5) =?> to-array()",
    $gen2ToInf =?> for-each-pair($gen2ToInf, $sum2) =?> take(5) =?> to-array(),
    "================",
    "==>  $gen2ToInf =?> filter(fn($n){$n mod 2 eq 1}) =?> get-current()",
    $gen2ToInf =?> filter(fn($n){$n mod 2 eq 1}) =?> get-current(),

    "$gen2ToInf =?> filter(fn($n){$n mod 2 eq 1}) =?> move-next() =?> get-current()",
    $gen2ToInf =?> filter(fn($n){$n mod 2 eq 1}) =?> move-next() =?> get-current(),
    "================", 
    "$gen2ToInf =?> filter(fn($n){$n mod 2 eq 1}) =?> take(10) =?> to-array()",
    $gen2ToInf =?> filter(fn($n){$n mod 2 eq 1}) =?> take(10) =?> to-array(),  
    "================", 
    "$gen2ToInf =?> filter(fn($n){$n mod 2 eq 1}) =?> take(10) =?> to-sequence()",
    $gen2ToInf =?> filter(fn($n){$n mod 2 eq 1}) =?> take(10) =?> to-sequence(),

    "================", 
    "$gen2ToInf =?> take-while(fn($n){$n lt 11}) =?> to-array()",
    $gen2ToInf =?> take-while(fn($n){$n lt 11}) =?> to-array(), 
    "$gen2ToInf =?> take-while(fn($n){$n lt 2}) =?> to-array()",
    $gen2ToInf =?> take-while(fn($n){$n lt 2}) =?> to-array(), 
    "================", 
    "$gen2ToInf =?> skip-while(fn($n){$n lt 11}) =?> take(5) =?> to-array()",
    $gen2ToInf =?> skip-while(fn($n){$n lt 11}) =?> take(5) =?> to-array(),
    "==> $gen2ToInf =?> skip-while(fn($n){$n lt 2})",
    $gen2ToInf =?> skip-while(fn($n){$n lt 2}),
    "
     ==> $gen2ToInf =?> skip-while(fn($n){$n lt 2}) =?> skip(1)",
     $gen2ToInf =?> skip-while(fn($n){$n lt 2}) =?> skip(1),
    "$gen2ToInf =?> some()",
     $gen2ToInf =?> some(),
     "let $empty := $gen2ToInf =?> empty-generator()
      return $empty =?> some()",
     let $empty := $gen2ToInf =?> empty-generator()
      return $empty =?> some(),
    "================",
    "$gen2ToInf =?>take(5) =?> filter(fn($n){$n ge 7}) =?> some()",
     $gen2ToInf =?>take(5) =?> filter(fn($n){$n ge 7}) =?> some(),  
     "$gen2ToInf =?>take(5) =?> some-where(fn($n){$n ge 7})",
     $gen2ToInf =?>take(5) =?> some-where(fn($n){$n ge 7}), 
     "$gen2ToInf =?>take(5) =?> some-where(fn($n){$n ge 6})",
     $gen2ToInf =?>take(5) =?> some-where(fn($n){$n ge 6}),
     "$gen2ToInf =?> some-where(fn($n){$n ge 100})",
     $gen2ToInf =?> some-where(fn($n){$n ge 100}),
     "================",
     "$gen2ToInf =?>take(10) =?> take(11) =?> to-array()",
     $gen2ToInf =?>take(10) =?> take(11) =?> to-array(),
     "$gen2ToInf =?>take(10) =?> skip(10) =?> to-array()",
     $gen2ToInf =?>take(10) =?> skip(10) =?> to-array(),
     "$gen2ToInf =?>take(10) =?> skip(9) =?> to-array()",     
     $gen2ToInf =?>take(10) =?> skip(9) =?> to-array(),
     "$gen2ToInf =?>take(10) =?> subrange(3, 12) =?> to-array()",
     $gen2ToInf =?>take(10) =?> subrange(3, 12) =?> to-array(),
     "$gen2ToInf =?>take(10) =?> subrange(5, 3) =?> to-array()",
     $gen2ToInf =?>take(10) =?> subrange(5, 3) =?> to-array(),
     "================",
     "$gen2ToInf =?>take(100) =?> chunk(20) =?> get-current()",
      $gen2ToInf =?>take(100) =?> chunk(20) =?> get-current(),
      "==>  $gen2ToInf =?> chunk(20) =?> take(5) =?> to-array()",
      $gen2ToInf =?> chunk(20) =?> take(5) =?> to-array(),
     "================",
     "$gen2ToInf =?>take(100) =?> chunk(20) =?> move-next() =?> get-current()",
      $gen2ToInf =?>take(100) =?> chunk(20) =?> move-next() =?> get-current(),
     "$gen2ToInf =?>take(100) =?> chunk(20) =?> move-next() =?> move-next() =?> get-current()", 
      $gen2ToInf =?>take(100) =?> chunk(20) =?> move-next() =?> move-next() =?> get-current(),
     "$gen2ToInf =?>take(100) =?> chunk(20) =?> skip(1) =?> get-current()",      
      $gen2ToInf =?>take(100) =?> chunk(20) =?> skip(1) =?> get-current(),
     "================",      
     "$gen2ToInf =?>take(100) =?> chunk(20) =?> for-each(fn($genX){$genX}) =?> to-array()",      
      $gen2ToInf =?>take(100) =?> chunk(20) =?> for-each(fn($genX){$genX}) =?> to-array(),
     "================",  
     "$gen2ToInf =?>take(10) =?> chunk(4) =?> to-array()",
      $gen2ToInf =?>take(10) =?> chunk(4) =?> to-array(),
      "$gen2ToInf =?>take(10) =?> chunk(4) =?> for-each(fn($arr){array:size($arr)}) =?> to-array()",
      $gen2ToInf =?>take(10) =?> chunk(4) =?> for-each(fn($arr){array:size($arr)}) =?> to-array(),
     "================", 
     "$gen2ToInf =?> subrange(10, 15) =?> concat($gen2ToInf =?> subrange(1, 9)) =?> to-array()",
     $gen2ToInf =?> subrange(10, 15) =?> concat($gen2ToInf =?> subrange(1, 9)) =?> to-array(),
     "================", 
     "$gen2ToInf =?> subrange(1, 5) =?> append(101) =?> to-array()",
     $gen2ToInf =?> subrange(1, 5) =?> append(101) =?> to-array(),
     "$gen2ToInf =?> subrange(1, 5) =?> prepend(101) =?> to-array()",
     $gen2ToInf =?> subrange(1, 5) =?> prepend(101) =?> to-array(),
     "==>  $gen2ToInf =?> append(101)",
     $gen2ToInf =?> append(101),
     "$gen2ToInf =?> prepend(101) =?> take(5) =?> to-array()",
     $gen2ToInf =?> prepend(101) =?> take(5) =?> to-array(),
     "================", 
     "$gen2ToInf =?> subrange(1, 5) =?> zip($gen2ToInf =?> subrange(6, 10)) =?> to-array()",
     $gen2ToInf =?> subrange(1, 5) =?> zip($gen2ToInf =?> subrange(6, 10)) =?> to-array(),
     "$gen2ToInf =?> subrange(1, 5) =?> zip($gen2ToInf =?> subrange(10, 20)) =?> to-array()",
     $gen2ToInf =?> subrange(1, 5) =?> zip($gen2ToInf =?> subrange(10, 20)) =?> to-array(),
     "==>  $gen2ToInf =?> zip($gen2ToInf =?> skip(5)) =?> take(10) =?> to-array()",
     $gen2ToInf =?> zip($gen2ToInf =?> skip(5)) =?> take(10) =?> to-array(),
     "$gen2ToInf =?> subrange(1, 5) =?> zip($gen2ToInf =?> subrange(10, 20)) =?> zip($gen2ToInf =?> subrange(30, 40)) =?> to-array()",
     $gen2ToInf =?> subrange(1, 5) =?> zip($gen2ToInf =?> subrange(10, 20)) =?> zip($gen2ToInf =?> subrange(30, 40)) =?> to-array(),
     "================", 
     "$gen2ToInf =?> make-generator(fn($numGenerated as xs:integer)
                                 {if($numGenerated le 9) then fn() {$numGenerated + 1} else -1} 
                             ) =?> to-array()",
     $gen2ToInf =?> make-generator(fn($numGenerated as xs:integer)
                                 {if($numGenerated le 9) then fn() {$numGenerated + 1} else -1} 
                             ) =?> to-array(),
     "================", 
     "$gen2ToInf =?> make-generator-from-array([1, 4, 9, 16, 25]) =?> to-array()",
      $gen2ToInf =?> make-generator-from-array([1, 4, 9, 16, 25]) =?> to-array(),
      "$gen2ToInf =?> make-generator-from-sequence((1, 8, 27, 64, 125)) =?> to-array()",
      $gen2ToInf =?> make-generator-from-sequence((1, 8, 27, 64, 125)) =?> to-array(), 
     "================", 
     "$gen2ToInf =?>take(10) =?> insert-at(3, ""XYZ"") =?> to-array()",
      $gen2ToInf =?>take(10) =?> insert-at(3, "XYZ") =?> to-array(),
      "$gen2ToInf =?>take(10) =?> insert-at(1, ""ABC"") =?> to-array()",
      $gen2ToInf =?>take(10) =?> insert-at(1, "ABC") =?> to-array(),
      "$gen2ToInf =?>take(10) =?> insert-at(11, ""PQR"") =?> to-array()",
      $gen2ToInf =?>take(10) =?> insert-at(11, "PQR") =?> to-array(),
      "==>  $gen2ToInf =?> insert-at(3, ""XYZ"") =?> take(10) =?> to-array()", 
      $gen2ToInf =?> insert-at(3, "XYZ") =?> take(10) =?> to-array(),
     (: , $gen2ToInf =?>take(10) =?> insert-at(12, "GHI") =?> to-array() :)  (:  Must raise error "Input Generator too-short." :) 
     "================", 
     "$gen2ToInf =?>take(10) =?> remove-at(3) =?> to-array()",
      $gen2ToInf =?>take(10) =?> remove-at(3) =?> to-array(),
      "$gen2ToInf =?>take(10) =?> remove-at(1) =?> to-array()",
      $gen2ToInf =?>take(10) =?> remove-at(1) =?> to-array(),
      "$gen2ToInf =?>take(10) =?> remove-at(10) =?> to-array()",
      $gen2ToInf =?>take(10) =?> remove-at(10) =?> to-array(),
      "==>  $gen2ToInf =?> remove-at(3) =?> take(10) =?> to-array()",
      $gen2ToInf =?> remove-at(3) =?> take(10) =?> to-array(),
      (: , $gen2ToInf =?>take(10) =?> remove-at(11) =?> to-array() :)        (:  Must raise error "Input Generator too-short." :) 
(::) 
     "================",
     "==>  $gen2ToInf =?> remove-where(fn($x){$x mod 3 eq 0}) =?> take(10) =?> to-array()",
      $gen2ToInf =?> remove-where(fn($x){$x mod 3 eq 0}) =?> take(10) =?> to-array(),   
       
     "================",
     "$gen2ToInf =?> make-generator-from-sequence((1,  3, 1, 2,  1, 2, 5, 2, 5)) =?> distinct() =?> to-array()",
      $gen2ToInf =?> make-generator-from-sequence((1,  3, 1, 2,  1, 2, 5, 2, 5)) =?> distinct() =?> to-array(),
      "$gen2ToInf =?> for-each(fn($n){$n idiv 10}) =?> take(50) =?> distinct() =?> to-array()",
      $gen2ToInf =?> for-each(fn($n){$n idiv 10}) =?> take(50) =?> distinct() =?> to-array(),
      "$gen2ToInf =?> for-each(fn($n){$n idiv 10}) =?> take(100) =?> distinct() =?> to-array()",
      $gen2ToInf =?> for-each(fn($n){$n idiv 10}) =?> take(100) =?> distinct() =?> to-array(),
      "==> $gen2ToInf =?> for-each(fn($n){$n idiv 10}) =?> distinct() =?> take(35) =?> to-array()",
      $gen2ToInf =?> for-each(fn($n){$n idiv 10}) =?> distinct() =?> take(35) =?> to-array(),
     
     "================",          
     "$gen2ToInf =?>take(10) =?> replace(fn($x){$x gt 4}, ""Replacement"") =?> to-array()",
      $gen2ToInf =?>take(10) =?> replace(fn($x){$x gt 4}, "Replacement") =?> to-array(),
      "$gen2ToInf =?>take(10) =?> replace(fn($x){$x lt 3}, ""Replacement"") =?> to-array()",
      $gen2ToInf =?>take(10) =?> replace(fn($x){$x lt 3}, "Replacement") =?> to-array(),
      "$gen2ToInf =?>take(10) =?> replace(fn($x){$x gt 10}, ""Replacement"") =?> to-array()",
      $gen2ToInf =?>take(10) =?> replace(fn($x){$x gt 10}, "Replacement") =?> to-array(),
      "$gen2ToInf =?>take(10) =?> replace(fn($x){$x gt 11}, ""Replacement"") =?> to-array()",
      $gen2ToInf =?>take(10) =?> replace(fn($x){$x gt 11}, "Replacement") =?> to-array(),
      "$gen2ToInf =?>take(10) =?> replace(fn($x){$x lt 2}, ""Replacement"") =?> to-array()",
      $gen2ToInf =?>take(10) =?> replace(fn($x){$x lt 2}, "Replacement") =?> to-array(),
      "==> $gen2ToInf =?> replace(fn($x){$x gt 4}, ""Replacement"") =?> take(10) =?> to-array()",
      $gen2ToInf =?> replace(fn($x){$x gt 4}, "Replacement") =?> take(10) =?> to-array(),
      "$gen2ToInf =?> replace(fn($x){$x lt 3}, ""Replacement"") =?> take(10) =?> to-array()",
      $gen2ToInf =?> replace(fn($x){$x lt 3}, "Replacement") =?> take(10) =?> to-array(),
    (:  
      Will result in endless loop:
      
      , "==>  ==>  ==>  $gen2ToInf =?> replace(fn($x){$x lt 2}, ""Replacement"") =?> take(10) =?> to-array() <==  <==  <==",
      $gen2ToInf?replace2(fn($x){$x lt 2}, "Replacement") =?> take(10) =?> to-array() 
    :)
    "================",
    "$gen2ToInf =?> empty-generator() =?> reverse() =?> to-array()",
    $gen2ToInf =?> empty-generator() =?> reverse() =?> to-array(),
    "$gen2ToInf =?> empty-generator() =?> append(2) =?> reverse() =?> to-array()",
    $gen2ToInf =?> empty-generator() =?> append(2) =?> reverse() =?> to-array(),
    "$gen2ToInf =?>take(10) =?> reverse() =?> to-array()",
    $gen2ToInf =?>take(10) =?> reverse() =?> to-array(),
    "================",
    "$genN =?> take(10) =?> contains(3)",
    $genN =?> take(10) =?> contains(3),
    "$genN =?> take(10) =?> contains(20)",
    $genN =?> take(10) =?> contains(20),
    "$genN =?> take(10) =?> contains(1)",    
    $genN =?> take(10) =?> contains(1), 
    "$genN =?> take(10) =?> contains(10)",     
    $genN =?> take(10) =?> contains(10),  
    "$genN =?> take(10) =?> contains(0)",
    $genN =?> take(10) =?> contains(0), 
    "$genN =?> take(10) =?> contains(11)",        
    $genN =?> take(10) =?> contains(11),
    "==> $genN =?> contains(15)",    
    $genN =?> contains(15), 
    "================",
    "$gen2ToInf =?>take(5) =?> fold-left(0, fn($x, $y){$x + $y})",
    $gen2ToInf =?>take(5) =?> fold-left(0, fn($x, $y){$x + $y}),
    "================",
    "$gen2ToInf =?>take(5) =?> fold-right(0, fn($x, $y){$x + $y})",
    $gen2ToInf =?>take(5) =?> fold-right(0, fn($x, $y){$x + $y}),
    "================",
    "==> $gen0toInf =?> for-each(fn($n){(2 * $n + 1) div $factorial(2*xs:decimal($n)})
              =?> take(8) =?> fold-left(0, fn($x, $y){$x + $y})",
    $gen0toInf =?> for-each(fn($n){(2*$n + 1) div $factorial(2*xs:decimal($n))}) =?> take(8) =?> fold-left(0, fn($x, $y){$x + $y}),
    "================",    
    "$gen0toInf =?> for-each(fn($n){(2*$n + 1) div $factorial(2*xs:decimal($n))}) =?> take(8) =?> scan-left(0, fn($x, $y){$x + $y}) =?> to-array()",
    $gen0toInf =?> for-each(fn($n){(2*$n + 1) div $factorial(2*xs:decimal($n))}) =?> take(8) =?> scan-left(0, fn($x, $y){$x + $y}) =?> to-array(),
    "================",
    "let $genSeqE := $gen0toInf =?> for-each(fn($n){(2*$n + 1) div $factorial(2*xs:decimal($n))}) =?> take(8) =?> scan-left(0, fn($x, $y){$x + $y}),
    $genSeqE-Next := $genSeqE =?> tail(),
    $genZipped := $genSeqE =?> zip($genSeqE-Next)
 return
    $genZipped =?> first-where(fn($pair){abs($pair(1) - $pair(2)) lt 0.000001})(2)",
    let $genSeqE := $gen0toInf =?> for-each(fn($n){(2*$n + 1) div $factorial(2*xs:decimal($n))}) =?> take(8) =?> scan-left(0, fn($x, $y){$x + $y}),
        $genSeqE-Next := $genSeqE =?> tail(),
        $genZipped := $genSeqE =?> zip($genSeqE-Next)
      return
        $genZipped =?> first-where(fn($pair){abs($pair(1) - $pair(2)) lt 0.000001})(2),        
    "================",
    
    "$gen2ToInf =?> empty-generator() =?> scan-left(0, fn($x, $y){$x + $y}) =?> to-array()",
    $gen2ToInf =?> empty-generator() =?> scan-left(0, fn($x, $y){$x + $y}) =?> to-array(),
    "$gen2ToInf =?>take(5) =?> scan-left(0, fn($x, $y){$x + $y}) =?> to-array()",
    $gen2ToInf =?>take(5) =?> scan-left(0, fn($x, $y){$x + $y}) =?> to-array(),
    "================",
    "$gen2ToInf =?> make-generator-from-sequence((1 to 10)) =?> scan-right(0, fn($x, $y){$x + $y}) =?> to-array()",
    $gen2ToInf =?> make-generator-from-sequence((1 to 10)) =?> scan-right(0, fn($x, $y){$x + $y}) =?> to-array(),
    "================",
    let $multShortCircuitProvider := fn($x, $y)
        {
          if($x eq 0) then fn(){0}
            else fn($z) {$x * $z}
        },
        $gen-5ToInf := $gen2ToInf =?> for-each(fn($n){$n -7})
     return
     (
       "let $multShortCircuitProvider := fn($x, $y)
        {
          if($x eq 0) then fn(){0}
            else fn($z) {$x * $z}
        },
            $gen-5ToInf := $gen2ToInf =?> for-each(fn($n){$n -7})
          return
            $gen2ToInf =?>take(5) =?> fold-lazy(1, $product, $multShortCircuitProvider),
            $gen-5ToInf =?> fold-lazy(1, $product, $multShortCircuitProvider)",
       $gen2ToInf =?>take(5) =?> fold-lazy(1, $product, $multShortCircuitProvider),
       $gen-5ToInf =?> fold-lazy(1, $product, $multShortCircuitProvider)
     ),
     "===============",
     "     let $myMap := {'John': 22, 'Ann': 28, 'Peter': 31}
      return 
        $gen2ToInf =?> make-generator-from-map($myMap) =?> to-array()",
     let $myMap := {"John": 22, "Ann": 28, "Peter": 31}
      return 
        $gen2ToInf =?> make-generator-from-map($myMap) =?> to-array(),
     "===============",        
     "let $myMap := {'John': 22, 'Ann': 28, 'Peter': 31},
          $genMap := $gen2ToInf =?> make-generator-from-map($myMap)
      return
        $genMap =?> to-map()" ,
     let $myMap := {"John": 22, "Ann": 28, "Peter": 31},
         $genMap := $gen2ToInf =?> make-generator-from-map($myMap)
      return
        $genMap =?> to-map(),
     "$gen2ToInf =?>take(10) =?> to-map()",
     $gen2ToInf =?>take(10) =?> to-map()         
   )
