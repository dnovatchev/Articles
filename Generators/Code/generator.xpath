declare namespace f = "http://www.w3.org/2005/xpath-functions-2025";
declare record f:generator 
   ( initialized as xs:boolean,
     endReached as xs:boolean,
     getCurrent as %method fn() as item()*,
     moveNext as %method fn(*) (: as f:generator, :),
     toArray := %method fn()
     {
       while-do( [., []],
                function( $inArr) 
                { $inArr(1)?initialized and not($inArr(1)?endReached) },                 
                function($inArr) 
                { array{$inArr(1)?moveNext(), 
                        array:append($inArr(2), $inArr(1)?getCurrent())
                       } 
                 }         
       ) (2)
     },
     
     take := %method fn($n as xs:integer) 
     {
      let $gen := if(not(?initialized)) then ?moveNext()
                    else .
       return
         if($gen?endReached or $n le 0) then $gen?emptyGenerator()
          else
            let $current := $gen?getCurrent(),
                $newResultGen := map:put(., "getCurrent", %method fn(){$current}),
                $nextGen := $gen?moveNext()
             return
               if($nextGen?endReached) then $newResultGen
                 else
                   let
                       $newResultGen2 :=  map:put($newResultGen, "moveNext", %method fn() {$nextGen?take($n -1)}) 
                     return
                       $newResultGen2
      },
      
      takeWhile := %method fn($pred as function(item()*) as xs:boolean)
      {
        let $gen := if(not(?initialized)) then ?moveNext()
                      else .
         return
           if($gen?endReached) then $gen?emptyGenerator()
            else      
              let $current := $gen?getCurrent()
                return
                  if(not($pred($current))) then $gen?emptyGenerator()
                  else
                    let $newResultGen := map:put(., "getCurrent", %method fn(){$current}),
                        $nextGen := ?moveNext()
                     return
                        if($nextGen?endReached) then $newResultGen
                        else
                          let $newResultGen2 :=  map:put($newResultGen, "moveNext", %method fn() {$nextGen?takeWhile($pred)}) 
                           return $newResultGen2  
      },
     
     skip := %method fn($n as xs:integer) 
     {
            if($n eq 0) then .
              else if(?endReached) then ?emptyGenerator()
              else 
                let $gen := if(not(?initialized)) then ?moveNext()
                             else .
                  return
                    if(not($gen?endReached)) then $gen?moveNext()?skip($n -1)
                      else $gen?emptyGenerator()                 

     },
     
     skipWhile := %method fn($pred as function(item()*) as xs:boolean)
     {
        let $gen := if(not(?initialized)) then ?moveNext()
                      else .
         return
           if($gen?endReached) then $gen?emptyGenerator()
            else
              let $current := $gen?getCurrent()
               return
                 if(not($pred($current))) then $gen
                  else $gen?moveNext()?skipWhile($pred)                    
     },
     
     some := %method fn()
     {
       ?initialized and not(?endReached)
     },
     
     someWhere := %method fn($pred)
     {
       ?filter($pred)?some()
     },
     
     subrange := %method fn($m as xs:integer, $n as xs:integer)
     {
       ?skip($m - 1)?take($n - $m + 1)
     },
     
     head := %method fn() {?take(1)?getCurrent()},
     tail := %method fn() {?skip(1)},
     
     at := %method fn($ind) {?subrange($ind, $ind + 1)?getCurrent()},
           
     for-each := %method fn($fun as function(*))
     {
      let $gen := if(not(?initialized)) then ?moveNext()
                    else .        
       return
         if(?endReached) then ?emptyGenerator()
          else
           let $current := $fun(?getCurrent()),
                $newResultGen := map:put(., "getCurrent", %method fn(){$current}),
                $nextGen := ?moveNext()
            return
              if($nextGen?endReached) then $newResultGen
                else
                  let $newResultGen2 :=  map:put($newResultGen, "moveNext", %method fn() {$nextGen?for-each($fun)}) 
                     return
                       $newResultGen2                    
      },
      
      for-each-pair := %method fn($gen2 as f:generator, $fun as function(*))
      {
        let $gen := if(not(?initialized)) then ?moveNext()
                    else .,
            $gen2 := if(not(?initialized)) then $gen2?moveNext()
                    else $gen2
         return
            if(?endReached or $gen2?endReached) then ?emptyGenerator() 
             else  
               let $current := $fun(?getCurrent(), $gen2?getCurrent()),
                   $newResultGen := map:put(., "getCurrent", %method fn(){$current}),
                   $nextGen1 := ?moveNext(),
                   $nextGen2 := $gen2?moveNext()
                return
                   if($nextGen1?endReached or $nextGen2?endReached) then $newResultGen
                     else
                       let $newResultGen2 := map:put($newResultGen, "moveNext", %method fn(){$nextGen1?for-each-pair($nextGen2, $fun)})
                         return
                           $newResultGen2    
                    
      },

      filter := %method fn($pred as function(item()*) as xs:boolean)
      {
             if(?initialized and ?endReached) then ?emptyGenerator()
              else
                let $getNextGoodGen := function($gen as map(*), 
                                             $pred as function(item()*) as xs:boolean)
                   {
                      if($gen?endReached) then $gen?emptyGenerator()
                      else
                        let $mapResult := 
                              while-do(
                                       $gen,
                                       function($x) { not($x?endReached) and not($pred($x?getCurrent()))},
                                       function($x) { $x?moveNext() }
                                       )   
                        return 
                          if($mapResult?endReached) then $gen?emptyGenerator()
                           else $mapResult                  
                   },
                   
                   $gen := if(?initialized) then . 
                             else ?moveNext(),
                   $nextGoodGen := $getNextGoodGen($gen, $pred)
                return
                  if($nextGoodGen?endReached) then $gen?emptyGenerator()
                  else
                    $nextGoodGen => map:put("moveNext", 
                                            %method fn() 
                                              {
                                                let $nextGoodGen := $getNextGoodGen(?inputGen?moveNext(), $pred)
                                                  return
                                                    if($nextGoodGen?endReached) then $nextGoodGen?emptyGenerator()
                                                    else
                                                      map:put(map:put($nextGoodGen, "moveNext", %method fn() {$nextGoodGen?moveNext()?filter($pred)}),
                                                                      "inputGen", $nextGoodGen
                                                              )
                                               }
                                           )
                                   =>
                                     map:put("inputGen", $nextGoodGen)
        },     
        
        toSequence := %method fn() {?toArray() => array:items()},     
        
        emptyGenerator := %method fn() 
        {
          . => map:put("initialized", true()) => map:put("endReached", true())
            => map:put("getCurrent", %method fn() {error((),"getCurrent() called on an emptyGenerator")})
            => map:put("moveNext", %method fn() {error((),"moveNext() called on an emptyGenerator")})
        },      
     *
   );

let $gen2ToInf := f:generator(initialized := true(), endReached := false(), 
                              getCurrent := %method fn(){?last +1},
                              moveNext := %method fn()
                              {
                                if(not(?initialized))
                                  then map:put(., "inittialized", true())
                                  else map:put(., "last", ?last + 1)
                              },
                              options := {"last" : 1}
                             ),
    $double := fn($n) {2*$n},
    $sum2 := fn($m, $n) {$m + $n}
  return    
  (
    $gen2ToInf?take(3)?toArray(),
    "================",    
    $gen2ToInf?take(3)?skip(2)?getCurrent(), $gen2ToInf?take(3)?getCurrent(), $gen2ToInf?take(3)?moveNext()?getCurrent(), $gen2ToInf?take(3)?moveNext()?moveNext()?getCurrent(),
    (: $gen2ToInf?take(3)?moveNext()?moveNext()?moveNext()?getCurrent(), :)
    "================",
    $gen2ToInf?getCurrent(),
    $gen2ToInf?moveNext()?getCurrent(),
    "================",
    $gen2ToInf?take(5) instance of f:generator,
    $gen2ToInf?skip(7) instance of f:generator,  
    "================",
    $gen2ToInf?subrange(4, 6)?getCurrent(), 
    $gen2ToInf?subrange(4, 6)?moveNext()?getCurrent(),
    $gen2ToInf?subrange(4, 6)?moveNext()?moveNext()?getCurrent(),
    (: $gen2ToInf?subrange(4, 6)?moveNext()?moveNext()?moveNext()?getCurrent() :) (: Must raise error:)    
    "================",    
    $gen2ToInf?subrange(4, 6)?head(),   
    $gen2ToInf?subrange(4, 6)?tail()?head(),
    $gen2ToInf?subrange(4, 6)?toArray(),
    "================", 
    $gen2ToInf?subrange(4, 6)?tail()?toArray(),
    "================",
    $gen2ToInf?at(5), 
    "================",
    $gen2ToInf?subrange(1, 5)?toArray(),
    $gen2ToInf?subrange(1, 5)?for-each($double)?toArray(),
    $gen2ToInf?take(5)?for-each($double)?toArray(),
    "================",
    $gen2ToInf?subrange(1, 5)?toArray(),
    $gen2ToInf?subrange(6, 10)?toArray(),
    $gen2ToInf?subrange(1, 5)?for-each-pair($gen2ToInf?subrange(6, 10), $sum2)?toArray(),   
    "================",
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?getCurrent(),
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?moveNext()?getCurrent(),
    "================",    
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?getCurrent(),
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?moveNext()?getCurrent(),
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?moveNext()?moveNext()?getCurrent(),
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?moveNext()?moveNext()?moveNext()?getCurrent(),
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?moveNext()?moveNext()?moveNext()?moveNext()?getCurrent(),
    "================", 
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?take(10)?toArray(),  
    "================", 
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?take(10)?toSequence(),
    "================", 
    $gen2ToInf?takeWhile(fn($n){$n < 11})?toArray(), 
    "================", 
    $gen2ToInf?skipWhile(fn($n){$n < 11})?take(5)?toArray(),
    "================",
     $gen2ToInf?some(),
     let $empty := $gen2ToInf?emptyGenerator()
      return $empty?some(),
    "================",
     $gen2ToInf?take(5)?filter(fn($n){$n ge 7})?some(),  
     $gen2ToInf?take(5)?someWhere(fn($n){$n ge 7}), 
     $gen2ToInf?take(5)?someWhere(fn($n){$n ge 6}) 
  )
